const nacl = require('tweetnacl');
const decodeUTF8 = require('tweetnacl-util').decodeUTF8;
const encodeUTF8 = require('tweetnacl-util').encodeUTF8;
const encodeBase64 = require('tweetnacl-util').encodeBase64;
const decodeBase64 = require('tweetnacl-util').decodeBase64;
const md5 = require('md5');
const axios = require('axios');

const Aqfr = require('@aqfr/aqfr.js').Aqfr;
const events = require('events');
const {AqfrChannel} = require('@aqfr/aqfr.channel.js');
const AsyncLock = require('async-lock');
const levelup = require('levelup')
const leveldown = require('leveldown')

const Chatkit = require('@pusher/chatkit-client')
// Init
require('browser-env')();
const credentials = {
    url: () =>
        `https://us1.pusherplatform.io/services/chatkit_token_provider/v1/ac994dfb-f0d8-42e8-9837-37128566a3b5/token`,
    instanceLocator: 'v1:us1:ac994dfb-f0d8-42e8-9837-37128566a3b5',
}
const {instanceLocator} = credentials;

class AqfrTokenProvider {
    constructor(aqfr, token) {
        this.token = token;
        this.aqfr = aqfr;
    }

    fetchToken() {
        const comp = this;
        return new Promise(function (resolve) {
            resolve(comp.token);
        });

    }

    getAqfr() {
        return this.aqfr;
    }
}

class AqfrSecureStorage {

    constructor() {
        this.nonce = null;
        this.key = null;
    }

    init(nonce, key) {
        this.nonce = nonce;
        this.key = key;
    }

    hydrateChannel(channel) {
        if (this.nonce == null || this.key == null) {
            return null;
        }
        return {
            kid: channel.kid,
            key: this.decrypt(this.key, this.nonce, channel.key),
            nonce: this.decrypt(this.key, this.nonce, channel.nonce),
            channelId: channel.channelId,
            members: channel.members
        }
    }

    dehydrateChannel(channel) {

        if (this.nonce == null || this.key == null) {
            return null;
        }
        return {
            kid: channel.kid,
            key: this.encrypt(channel.key, this.key, this.nonce),
            nonce: this.encrypt(channel.nonce, this.key, this.nonce),
            channelId: channel.channelId,
            members: channel.members
        }

    }

    hydrateKeySet(keySet) {
        if (this.nonce == null || this.key == null) {
            return null;
        }
        return {
            sig: {
                alg: keySet.sig.alg,
                kid: keySet.sig.kid,
                use: keySet.sig.use,
                keyPair: {
                    publicKey: decodeBase64(keySet.sig.keyPair.publicKey),
                    secretKey: decodeBase64(this.decrypt(this.key, this.nonce,
                        keySet.sig.keyPair.secretKey))
                }
            },
            enc: {
                alg: keySet.enc.alg,
                kid: keySet.enc.kid,
                use: keySet.enc.use,
                keyPair: {
                    publicKey: decodeBase64(keySet.enc.keyPair.publicKey),
                    secretKey: decodeBase64(this.decrypt(this.key, this.nonce,
                        keySet.enc.keyPair.secretKey))
                }
            },

            xrpHash: keySet.xrpHash
        }
    }

    dehydrateKeySet(keySet) {
        if (this.nonce == null || this.key == null) {
            return null;
        }
        return {
            xrpHash: keySet.xrpHash,
            enc: {
                alg: keySet.enc.alg,
                kid: keySet.enc.kid,
                use: keySet.enc.use,
                keyPair: {
                    publicKey: encodeBase64(keySet.enc.keyPair.publicKey),
                    secretKey: this.encrypt(
                        encodeBase64(keySet.enc.keyPair.secretKey), this.key,
                        this.nonce)
                }
            },
            sig: {
                alg: keySet.sig.alg,
                kid: keySet.sig.kid,
                use: keySet.sig.use,
                keyPair: {
                    publicKey: encodeBase64(keySet.sig.keyPair.publicKey),
                    secretKey: this.encrypt(
                        encodeBase64(keySet.sig.keyPair.secretKey), this.key,
                        this.nonce)
                }
            }
        }
    }

    dehydrateXrpAddress(xrpAddress) {
        if (this.nonce == null || this.key == null) {
            return null;
        }
        return {
            addressStatus: xrpAddress.addressStatus,
            address: xrpAddress.address,
            secret: this.encrypt(xrpAddress.secret, this.key, this.nonce)
        }
    }

    hydrateXrpAddress(xrpAddress) {
        console.log('in hydrate xrp address');
        if (this.nonce == null || this.key == null) {
            return null;
        }
        return {
            addressStatus: xrpAddress.addressStatus,
            address: xrpAddress.address,
            secret: this.decrypt(this.key, this.nonce, xrpAddress.secret)
        }
    }

    keyFromSeed(seed) {
        return encodeBase64(
            md5(seed));
    }

    randomKey() {
        return encodeBase64(
            nacl.randomBytes(nacl.secretbox.keyLength));
    }

    randomNonce() {
        return encodeBase64(
            nacl.randomBytes(nacl.secretbox.nonceLength));
    }

    decodeKey(key) {
        try {
            const k = decodeBase64(key);
            if (k.length !== nacl.secretbox.keyLength) {
                console.log(
                    'Bad key length: must be ' + nacl.secretbox.keyLength
                    + ' bytes');
                return null;
            }
            return k;
        } catch (e) {
            console.log('Failed to decode key from Base64');
            return null;
        }
    }

    decodeNonce(nonce) {
        try {
            const n = decodeBase64(nonce);
            if (n.length !== nacl.secretbox.nonceLength) {
                console.log(
                    'Bad nonce length: must be ' + nacl.secretbox.nonceLength
                    + ' bytes');
                return null;
            }
            return n;
        } catch (e) {
            this.error('Failed to decode nonce from Base64');
            return null;
        }
    };

    encrypt(message, key, nonce) {
        const m = decodeUTF8(message);
        const box = nacl.secretbox(m, this.decodeNonce(nonce),
            this.decodeKey(key));
        console.log('box type:' + (typeof box));
        return encodeBase64(box);
    }

    decrypt(k, n, box) {
        var b;
        var m;
        try {
            b = decodeBase64(box);
        } catch (ex) {
            console.log('Cannot decode box:' + ex);
            return null;
            ;
        }
        m = nacl.secretbox.open(b, this.decodeNonce(n), this.decodeKey(k));
        if (m === false) {
            console.log('Failed to decrypt');
            return null;
        }
        try {
            return encodeUTF8(m);
        } catch (ex) {
            console.log('Cannot decode decrypted message to string');
            return;
        }
    }

}

class AqfrNetworkClient extends events.EventEmitter {

    constructor(botName, password) {
        super();
        this.botName = botName;
        this.password = password;
    }

    sendMessage( userId, text ) {
        const comp = this;
        return new Promise( function(resolve, reject) {
            {
                comp.rooms.map(room => {
                    var roomName = room.name;
                    roomName = roomName.replace(comp.user.id, '');

                    if (roomName === userId) {
                        comp.aqfrChannel.encryptForChannel(
                            room.customData.correlation_id,
                            {message: text}).then(
                            function (encrypted) {
                                comp.user.sendMessage({
                                    text: JSON.stringify(encrypted),
                                    roomId: room.id,
                                })
                                resolve({status: 'sent'})
                            });
                    }

                });
                resolve({status: 'unknown'})
            }});

    }

    async onChannel(channel) {
        const comp = this;
        this.lock.acquire(channel.channelId, function (cb) {

            console.log('-->CHANNEL1:' + channel.channelId);
            const dehydratedChannel = comp.aqfrSecureStorage.dehydrateChannel(
                channel);
            comp.userIdDb.put('aqfr-channel-' + channel.channelId,
                JSON.stringify({
                    _id: 'aqfr-channel-' + channel.channelId,
                    channel: dehydratedChannel,
                    entryType: 'aqfrChannel'
                })).then(function (putResult) {
                console.log('put1:' + JSON.stringify(putResult));
                cb(putResult);
            });

            console.log('<--CHANNEL1: ' + channel.channelId);
        }, function (err, ret) {
            console.log('channel-lock release:' + channel.channelId);
        }, {});
    }

    sayHi() {
        console.log('hi');
    }

    checkAddressStatus(newAddress) {
        const comp = this;
        return new Promise(function (resolve, reject) {
            comp.aqfr2.promiseWsAccountInfo(
                newAddress.address).then(
                function (accountCheck) {
                    console.log('response:' + JSON.stringify(
                        accountCheck));
                    if (typeof accountCheck.error
                        !== 'undefined'
                        && typeof accountCheck.error
                        !== 'actNotFound') {
                        newAddress.addressStatus = 'unfunded';
                    } else {
                        newAddress.addressStatus = 'funded';
                    }
                    console.log('new addressssss updated:' + JSON.stringify(
                        newAddress));
                    resolve(newAddress);
                });
        });

    }

    persistXrpAddressToUserDb(xrpAddressDoc) {
        const comp = this;
        return new Promise(function (resolve, reject) {
            // -- persist the
            console.log('--> persist xrp address to userDb:' + JSON.stringify({
                _id: 'xrpAddress',
                address: comp.aqfrSecureStorage.dehydrateXrpAddress(
                    xrpAddressDoc),
                entryType: 'xrpAddress'
            }));
            comp.userIdDb.put('xrpAddress', JSON.stringify({
                _id: 'xrpAddress',
                address: comp.aqfrSecureStorage.dehydrateXrpAddress(
                    xrpAddressDoc),
                entryType: 'xrpAddress'
            })).then(function (resultDoc) {
                console.log(
                    '<-- persisted xrp address to userDb:' + JSON.stringify(
                    xrpAddressDoc));
                resolve(xrpAddressDoc)
            }).catch(function (error) {
                console.log('received error on persist xrp database:' + error);
                reject(error);
            });
        });
    }

    loadAqfrKeyStore() {
        const comp = this;
        return new Promise(function (resolve) {
            const keystore = {};
            comp.userIdDb.createReadStream()
            .on('data', function (data) {
                const parsed = JSON.parse(data.value.toString());
                if (parsed.entryType === 'aqfrKeySet') {
                    keystore[parsed.keyset.xrpHash] = comp.aqfrSecureStorage.hydrateKeySet(
                        parsed.keyset);
                    if (parsed._id.indexOf('current') > -1) {
                        keystore.current = comp.aqfrSecureStorage.hydrateKeySet(
                            parsed.keyset);
                    }
                }
            })
            .on('error', function (err) {
                console.log('Oh my!', err)
            })
            .on('close', function () {
                console.log('Stream closed')
            })
            .on('end', function () {
                console.log('Stream ended');
                resolve(keystore)
            })

        });
    }

    getXrpAddress() {
        const comp = this;
        return new Promise(function (resolve, reject) {
            comp.userIdDb.get('xrpAddress').then(function (doc) {
                const xrpAddress = JSON.parse(doc.toString());

                if (typeof xrpAddress.address !== 'undefined') {
                    comp.checkAddressStatus(
                        comp.aqfrSecureStorage.hydrateXrpAddress(
                            xrpAddress.address)).then(
                        function (addressStatusResponse) {
                            comp.persistXrpAddressToUserDb(
                                addressStatusResponse).then(
                                function (persistResponse) {
                                    resolve(persistResponse);
                                })
                        });
                } else {
                    const newAddress = comp.aqfr2.generateNewXrpAddress();
                    comp.checkAddressStatus(newAddress).then(
                        function (addressStatusResponse) {
                            comp.persistXrpAddressToUserDb(
                                addressStatusResponse).then(
                                function (persistResponse) {
                                    resolve(persistResponse);
                                })
                        });
                }
            }).catch(function (onRejected) {
                const newAddress = comp.aqfr2.generateNewXrpAddress();
                comp.checkAddressStatus(newAddress).then(
                    function (addressStatusResponse) {
                        comp.persistXrpAddressToUserDb(
                            addressStatusResponse).then(
                            function (persistResponse) {
                                resolve(persistResponse);
                            })
                    });

            });
        });

    }

    persistUserNameToUserDb(userName) {
        const comp = this;
        return new Promise(function (resolve) {
            comp.userIdDb.get('aqfrNetworkName')
            .then(function (doc) {
                comp.userIdDb.put('aqfrNetworkName',
                    JSON.stringify({
                        _id: 'aqfrNetworkName',
                        _rev: doc._rev,
                        name: userName,
                        entryType: 'aqfrNetworkName'
                    })).then(function (newDoc) {
                    resolve(newDoc);
                });
            })
            .catch(function (err) {
                comp.userIdDb.put('aqfrNetworkName',
                    JSON.stringify({
                        _id: 'aqfrNetworkName',
                        name: userName,
                        entryType: 'aqfrNetworkName'
                    })).then(function (doc) {
                    resolve(doc);
                });
            });
        });
    }

    createUnfundedNetworkConnection() {
        const comp = this;
        const profileCreate = {
            userName: this.botName,
            xrpAddress: comp.xrpAddress.address,
            avatarData: 'data:image/png;base64,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'
        }
        return new Promise(function (resolve) {
            axios.post(
                'https://api.aqfr.network/v1/initAddress',
                profileCreate).then(function (response) {
                console.log(
                    "LOGIN RESPONSE:"
                    +
                    JSON.stringify(
                        response.data));
                if (typeof response.data.errors
                    !== 'undefined'
                    && response.data.errors.length
                    > 0) {
                    resolve({error: response.data.errors[0]});
                } else {
                    //comp.central = response.data.address;
                    console.log('central:' + response.data.address);

                    comp.persistUserNameToUserDb(profileCreate.userName)
                    .then(function (aqfrNetworkNameDoc) {

                        resolve({
                            userId: profileCreate.userName,
                            connection: response.data
                        })

                    });

                }
            })
        });

    }

    loadAqfrChannels() {
        const comp = this;
        return new Promise(function (resolve) {
            const channels = {};
            comp.userIdDb.createReadStream()
            .on('data', function (data) {

                const parsed = JSON.parse(data.value.toString());
                if (parsed.entryType === 'aqfrChannel') {
                    channels[parsed.channel.channelId] = comp.aqfrSecureStorage.hydrateChannel(
                        parsed.channel)
                }
            })
            .on('error', function (err) {
                console.log('Oh my!', err)
            })
            .on('close', function () {
                console.log('Stream closed')
            })
            .on('end', function () {
                resolve(channels)
            })

        });
    }

    createNetworkConnection(profileCreate) {
        const comp = this;
        return new Promise(function (resolve) {
            comp.aqfr2.generateSignedAndEncryptedMessage(
                profileCreate,
                comp.central.address)
            .then(function (msg) {
                axios.post(
                    'https://api.aqfr.network/v1/message',
                    msg)
                .then(function (msg) {
                    comp.aqfr2.handleSignedAndEncryptedMessage(
                        msg.data).then(
                        function (handled) {
                            if (typeof handled.msg_payload.errors
                                !== 'undefined'
                                && handled.msg_payload.errors.length
                                > 0) {
                                resolve({error: 'The username already exists'});
                            } else {
                                comp.persistUserNameToUserDb(
                                    profileCreate.userName)
                                .then(function (aqfrNetworkNameDoc) {
                                    comp.loginResponse = {
                                        userId: profileCreate.userName,
                                        connection: handled.msg_payload
                                    };

                                    resolve({
                                        userId: profileCreate.userName,
                                        connection: handled.msg_payload
                                    })
                                });
                            }
                        })
                });
            });
        });
    }

    onAqfrKeySet(hash, keyset) {
        const comp = this;
        const dehydratedKeySet = this.aqfrSecureStorage.dehydrateKeySet(keyset);
        this.userIdDb.put('aqfr-keyset-' + hash.substring(6), JSON.stringify({
            _id: 'aqfr-keyset-' + hash.substring(6),
            keyset: dehydratedKeySet,
            entryType: 'aqfrKeySet'
        })).then(function (keysDoc) {

            comp.userIdDb.put('aqfr-keyset-current', JSON.stringify({
                _id: 'aqfr-keyset-current',
                keyset: dehydratedKeySet,
                entryType: 'aqfrKeySet'
            })).then(function (currentKeysDoc) {
                console.log(
                    '<-- aqfr keyset persisted:' + hash + ' ' + hash.substring(
                    6));
            })
        });

    }

    postInit() {
        const comp = this;
        this.aqfr2.on('account-balance',
            function (balance) {
                console.log('XRP Balance Updated:'
                    + balance);
                comp.balance = balance;
                comp.emit('account-balance', balance);
            });
        comp.aqfr2.subscribe(
            function (notification) {
                if (typeof notification.msg_payload.message_type
                    !== 'undefined' &&
                    notification.msg_payload.message_type
                    === 'channel_keys') {
                    //channelId, kid, key, nonce, members
                    console.log(
                        'new channel keys received:'
                        + notification.msg_payload.channel_id);
                    comp.aqfrChannel.updateChannel(
                        notification.msg_payload.channel_id,
                        notification.msg_payload.channel_kid,
                        notification.msg_payload.key,
                        notification.msg_payload.nonce,
                        notification.msg_payload.members);

                    console.log(
                        'Encrypted Channel Keys Received from '
                        + notification.msg_raw.address);

                    comp.aqfr2.promiseWsAccountInfo(
                        comp.aqfr2.xrpAddress).then(
                        function (accountInfo) {
                            // noop
                        }
                    );
                } else if (typeof notification.msg_payload.message_type
                    !== 'undefined' &&
                    notification.msg_payload.message_type
                    === 'payment_notification') {
                    //channelId, kid, key, nonce, members
                    console.log(
                        'XRP Payment Received.  Amount='
                        +
                        notification.msg_payload.amount
                        + ', from='
                        + notification.msg_raw.address
                        + ', withMessage=' +
                        notification.msg_payload.message);

                    comp.aqfr2.promiseWsAccountInfo(
                        comp.aqfr2.xrpAddress).then(
                        function (accountInfo) {
                            // noop
                        }
                    );
                }
            }, comp.central.address);

        new Chatkit.ChatManager({
            tokenProvider: new AqfrTokenProvider(
                comp.aqfr2,
                comp.loginResponse.connection.key.access_token),
            instanceLocator,
            userId: comp.botName
        })
        .connect({
            onUserStartedTyping: function (room, user) {
                console.log('started typing:' + JSON.stringify(user.id));
                comp.emit('user-start-typing', {
                    room: room.id,
                    user_id: user.id
                });
            },
            onUserStoppedTyping: function (room, user) {
                console.log('not typing:' + JSON.stringify(user.id));
                comp.emit('user-stop-typing', {
                    room: room.id,
                    user_id: user.id
                });
            },
            onAddedToRoom: function (room) {
                console.log('on added to room:' + room.id);
                if (!comp.user.roomSubscriptions[room.id]) {
                    const broadcastMsg = {
                        room: room.id,
                        user_id: room.id.replace( comp.botName, ''),
                    };
                    comp.emit('user-new', broadcastMsg);
                    comp.user.subscribeToRoom({
                        roomId: room.id,
                        hooks: {onMessage: (e) => comp.addMessage(e)},
                    });
                    console.log('subscribed to room:' + room.id);
                }
            },
            onRemovedFromRoom: function (event) {
                console.log('remove from room:' + JSON.stringify(event));
            },
            onPresenceChanged: function (state, user) {
                console.log('set user presence:' + user.id + '->' + state.current);
                comp.emit('user-presence-update', {
                    user_id : user.id,
                    presence: state.current
                });
            }
        })
        .then(user => {
            // Subscribe to all rooms the user is a member of
            Promise.all(
                user.rooms.map(room =>
                    user.subscribeToRoom({
                        roomId: room.id,
                        hooks: {
                            onMessage: function (mssage) {
                                comp.addMessage(mssage);
                            }
                        },
                    })
                )
            ).then(rooms => {
                comp.user = user;
                comp.rooms = rooms;

            })
        })
        .catch(error => console.log('Error on connection', error))

    }

    addMessage(payload) {
        const comp = this;
        this.userIdDb.get('msg:' + payload.id).then(function(response) {
            //noop
        })
        .catch(function(error) {

            if (payload.text.indexOf('"delivery_type":"nacl_secret_box"')
                > -1) {

                comp.aqfrChannel.decryptForChannel(
                    JSON.parse(payload.text)).then(function (decrypted) {
                    payload.text = decrypted.payload.message;

                    console.log('decrypted:' + JSON.stringify(decrypted));
                    const channel = comp.aqfrChannel.channels[decrypted.raw.channel_id];

                    const channelMsg = {
                        channel_id : channel.channelId,
                        kid : channel.kid,
                        channel_members: channel.members
                    }

                    const senderMsg = {
                        user_id: payload.sender.id };

                    // -- the message came from us.
                    if (payload.sender.id === comp.botName) {

                            senderMsg.xrp_address = comp.aqfr2.xrpAddress;
                            senderMsg.sender_type = 'us';
                    }
                    else {
                        if(channel.members[0] == comp.aqfr2.xrpAddress) {
                            senderMsg.xrpAddress = channel.members[1];
                        }
                        else {
                            senderMsg.xrpAddress = channel.members[0];
                        }
                        senderMsg.sender_type = 'them';
                    }

                    comp.userIdDb.put('msg:' + payload.id,
                        JSON.stringify({
                            _id: 'msg:' +payload.id,
                            room: payload.room.id,
                            msg: {
                                decrypted: decrypted,
                                type: 'encrypted',
                                text: payload.text,
                                room: payload.room.id,
                                sender: senderMsg,
                                channel: channelMsg
                            },
                            entryType: 'message'
                        })).then(function (newDoc) {
                        comp.emit('message', {
                            _id: 'msg:' +payload.id,
                            msg: {

                                decrypted: decrypted,
                                type: 'encrypted',
                                text: payload.text,
                                room: payload.room.id,
                                sender: senderMsg,
                                channel: channelMsg
                            },
                            entryType: 'message'
                        })
                    });

                })
            } else {

                comp.userIdDb.put('msg:' + payload.id,
                    JSON.stringify({
                        _id: 'msg:' +payload.id,
                        msg: {
                            type: 'encrypted',
                            text: payload.text
                        },
                        entryType: 'message'
                    })).then(function (newDoc) {

                });
            }
        });



    }

    init() {
        const comp = this;
        return new Promise(function (resolve, reject) {

            comp.lock = new AsyncLock();
            comp.aqfr2 = new Aqfr();
            comp.aqfrChannel = new AqfrChannel(comp.aqfr2);
            comp.aqfrSecureStorage = new AqfrSecureStorage(comp.aqfr2);
            comp.aqfrChannel.on('channel', function (channel) {
                comp.onChannel(channel).then(function (result) {
                    console.log('channel process:' + channel.channelId);
                });
            });

            comp.aqfr2.connectWs({}).then(function (result) {

                comp.userIdDb = levelup(leveldown('./data'));
                const nonce = comp.aqfrSecureStorage.randomNonce();

                comp.userIdDb.get('pwdCheck').then(function (check) {
                    const pwdCheck = JSON.parse(check.toString());

                    if (pwdCheck.pwdCheck.value ===
                        comp.aqfrSecureStorage.encrypt('aqfr.rocks',
                            comp.aqfrSecureStorage.keyFromSeed(comp.password),
                            pwdCheck.pwdCheck.nonce)
                    ) {
                        comp.aqfrSecureStorage.init(pwdCheck.pwdCheck.nonce,
                            comp.aqfrSecureStorage.keyFromSeed(comp.password));
                        comp.getXrpAddress().then(function (response) {
                            const xrpAddress = response;
                            axios.get(
                                'https://api.aqfr.network/v1/bootstrap').then(
                                function (central) {
                                    comp.central = central.data;
                                    console.log('got central:' + JSON.stringify(
                                        central.data));
                                    comp.loadAqfrKeyStore().then(
                                        function (keystore) {
                                            xrpAddress.keyStore = keystore;

                                            xrpAddress.keyStoreListener = comp;
                                            comp.xrpAddress = xrpAddress;
                                            if (xrpAddress.addressStatus
                                                === 'unfunded') {
                                                comp.createUnfundedNetworkConnection().then(
                                                    function (loginresponse) {
                                                        xrpAddress.xrpAddress = xrpAddress.address;
                                                        comp.aqfr2.initAccount(
                                                            xrpAddress).then(
                                                            function (inited) {

                                                                console.log(
                                                                    'xrp address initialized:'

                                                                    + JSON.stringify(
                                                                    comp.central));
                                                                comp.aqfr2.rotateKeys(
                                                                    comp.central.address)
                                                                .then(
                                                                    function (rotated) {
                                                                        console.log(
                                                                            '$$$keys rotated:'
                                                                            + JSON.stringify(
                                                                            rotated));
                                                                        comp.loadAqfrChannels().then(
                                                                            function (channels) {
                                                                                comp.aqfrChannel.channels = channels;
                                                                                comp.createNetworkConnection(
                                                                                    {userName: comp.botName}).then(
                                                                                    function (response) {
                                                                                        console.log(
                                                                                            'new network connection response1:'
                                                                                            + JSON.stringify(
                                                                                            response));
                                                                                        comp.postInit();
                                                                                        resolve(
                                                                                            {status: 'inited'})
                                                                                    })
                                                                            });

                                                                    })
                                                            });
                                                    });
                                            } else {
                                                console.log('FUUUUUUNDED');
                                                xrpAddress.xrpAddress = xrpAddress.address;
                                                comp.aqfr2.initAccount(
                                                    xrpAddress).then(
                                                    function (inited) {


                                                        comp.aqfr2.rotateKeys(
                                                            comp.central.address)
                                                        .then(
                                                            function (rotated) {

                                                                comp.loadAqfrChannels().then(
                                                                    function (channels) {
                                                                        comp.aqfrChannel.channels = channels;
                                                                        comp.createNetworkConnection(
                                                                            {userName: comp.botName}).then(
                                                                            function (response) {

                                                                                comp.postInit();
                                                                                resolve(
                                                                                    {status: 'inited'})
                                                                            })
                                                                    });

                                                            })
                                                    });

                                            }
                                        });
                                });

                        });

                    } else {
                        console.log(
                            'Please try again. The password does not match.');
                        reject('Please try again. The password does not match.')
                    }
                }).catch(function (error) {

                    comp.userIdDb.put('pwdCheck', JSON.stringify({
                        _id: 'pwdCheck',
                        pwdCheck: {
                            nonce: nonce,
                            value: comp.aqfrSecureStorage.encrypt('aqfr.rocks',
                                comp.aqfrSecureStorage.keyFromSeed(
                                    comp.password), nonce)
                        },
                        entryType: 'pwdCheck'
                    })).then(function (result) {
                        comp.aqfrSecureStorage.init(nonce,
                            comp.aqfrSecureStorage.keyFromSeed(comp.password));
                        comp.getXrpAddress().then(function (response) {
                            const xrpAddress = response;
                            axios.get(
                                'https://api.aqfr.network/v1/bootstrap').then(
                                function (central) {

                                    comp.central = central.data;
                                    comp.loadAqfrKeyStore().then(
                                        function (keystore) {
                                            xrpAddress.keyStore = keystore;
                                            console.log(
                                                "XRP ADDRESS:" + JSON.stringify(
                                                xrpAddress));
                                            xrpAddress.keyStoreListener = comp;

                                            comp.xrpAddress = xrpAddress;
                                            if (xrpAddress.addressStatus
                                                === 'unfunded') {
                                                comp.createUnfundedNetworkConnection().then(
                                                    function (loginresponse) {
                                                        xrpAddress.xrpAddress = xrpAddress.address;
                                                        comp.aqfr2.initAccount(
                                                            xrpAddress).then(
                                                            function (inited) {


                                                                comp.aqfr2.rotateKeys(
                                                                    comp.central.address)
                                                                .then(
                                                                    function (rotated) {

                                                                        comp.createNetworkConnection(
                                                                            {userName: comp.botName}).then(
                                                                            function (response) {

                                                                                comp.postInit();
                                                                                resolve(
                                                                                    {status: 'inited'})
                                                                            })
                                                                    })
                                                            });
                                                    });
                                            } else {
                                                xrpAddress.xrpAddress = xrpAddress.address;
                                                comp.aqfr2.initAccount(
                                                    xrpAddress).then(
                                                    function (inited) {


                                                        comp.aqfr2.rotateKeys(
                                                            comp.central.address)
                                                        .then(
                                                            function (rotated) {

                                                                comp.createNetworkConnection(
                                                                    {userName: comp.botName}).then(
                                                                    function (response) {

                                                                        comp.postInit();
                                                                        resolve(
                                                                            {status: 'inited'})
                                                                    })
                                                            })
                                                    });

                                            }
                                        });

                                });
                        });
                    }).catch(function (error) {
                        reject(error);
                    });
                });

            });

        });

    }

    close() {
        this.userIdDb.close().then(function () {
            console.log('user db is closed');
        });
    }
}

module.exports = AqfrNetworkClient;

