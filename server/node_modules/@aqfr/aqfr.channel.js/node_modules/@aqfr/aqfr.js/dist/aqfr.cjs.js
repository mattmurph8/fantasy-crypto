'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const RippleAPI = require('ripple-lib').RippleAPI;
const axios = require('axios');
const WebSocket = require('isomorphic-ws');
const events = require('events');
const nacl = require('tweetnacl');
const decodeUTF8 = require('tweetnacl-util').decodeUTF8;
const encodeUTF8 = require('tweetnacl-util').encodeUTF8;
const encodeBase64  = require('tweetnacl-util').encodeBase64;
const decodeBase64 = require('tweetnacl-util').decodeBase64;

class Aqfr extends events.EventEmitter {

    constructor() {
        super();
        this.api = null;
        this.xrpAddress = null;
        this.secret = null;
        this.connectedApi = false;
        this.mode = null;
        this.ws = null;
        this.requestMap = {};
        this.subscribeCallback = null;
        this.dataCallback = null;
        this.network = null;
        this.id = 0;
        this.sequence = 0;
        this.keyStore = {};
        this.wsOptions = null;
        this.pingTimeout = null;
        this.monitorConnection();
        this.balance = { balance : "PENDING" };
        this.keyStoreListener = function (keySetXRPHash, keySet) {
            console.log('updated key set hash: ' +  keySetXRPHash + ', encKid:' + keySet.enc.kid + ', sigKid:' + keySet.sig.kid);
        };
    }

    heartbeat() {
        if (this.pingTimeout != null) {
            clearTimeout(this.pingTimeout);
        }
        const aqfr = this;

        this.pingTimeout = setTimeout(() => {
            console.log('ping timed out');
            if (aqfr.ws != null) {
                aqfr.connectedApi = false;
            }
        }, 5000);


        if (this.xrpAddress !== null) {
            console.log('Heartbeat: -> ping account info');
            this.promiseWsAccountInfo(this.xrpAddress).then(function(response) {
                console.log('Heartbeat: <- ping account info');
                aqfr.connectedApi = true;
                if (aqfr.pingTimeout != null) {
                    clearTimeout(aqfr.pingTimeout);
                }
                setTimeout(function() {
                    aqfr.heartbeat();
                }, 30000);
            });
        }
        else {
            console.log('Heartbeat: -> ping');
            this.ping().then(function(response) {
                console.log('Heartbeat: <- ping');
                aqfr.connectedApi = true;
                if (aqfr.pingTimeout != null) {
                    clearTimeout(aqfr.pingTimeout);
                }
                setTimeout(function() {
                    aqfr.heartbeat();
                }, 30000);
            });
        }

    }

    monitorConnection() {
        const aqfr = this;
        setInterval(function() {
            if (aqfr.ws == null && aqfr.wsOptions != null) {
                aqfr.connectedApi = false;
                aqfr.connectWs(aqfr.wsOptions).then(function (connectionResult) {
                    console.log("Monitor Connection: reconnection result:" + connectionResult);
                });
            }
            else if (aqfr.wsOptions == null) {
                console.log("Monitor Connection: no ws options, not reconnecting");
            }
            else if (aqfr.connectedApi) {
                console.log("Monitor Connection: already connected, not reconnecting:" + aqfr.ws.readyState);

            }
        }, 60000);
    }

    async saveAndNotify( key, data,
        notificationAddress ) {
        const memoResponse1 = await this.setMemo(key, data);
        await this.setDomain(
            'xrp://' + memoResponse1.tx_json.hash );
        if (typeof notificationAddress !== 'undefined' && notificationAddress != null) {
            await this.pay(notificationAddress, "20",
                'notification',
                {hash: 'xrp://' + memoResponse1.tx_json.hash});
        }
        return 'xrp://' +memoResponse1.tx_json.hash;
    }

    async generateSignedAndEncryptedMessage( msg, destinationAddress ) {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            aqfr.getFirstRecordByType(destinationAddress, 'publickeys').then(function(theirJwkRecord) {
                if (typeof theirJwkRecord.hash === 'undefined') {
                    console.log("could not find their jwks");
                    reject({errors: [{
                        error: 'could not find their jwks'
                        }]});
                }
                else {
                    const currentKeySet = aqfr.keyStore.current;

                    const nonce = new Uint8Array(nacl.box.nonceLength);
                    for (var i = 0; i < nonce.length; i++) nonce[i] = (32 + i)
                        & 0xff;
                    const decodeMsg = decodeUTF8(JSON.stringify(msg));
                    const box =
                        encodeBase64(
                            nacl.box(decodeMsg, nonce, decodeBase64(
                                theirJwkRecord.data.data_json.enc.key),
                                currentKeySet.enc.keyPair.secretKey));

                    const encrypted = {
                        delivery_type: 'nacl_box',
                        source_jku: currentKeySet.xrpHash,
                        source_kid: currentKeySet.enc.kid,
                        target_jku: theirJwkRecord.hash,
                        target_kid: theirJwkRecord.data.data_json.enc.kid,
                        payload: box,
                        nonce: encodeBase64(nonce)
                    };
                    resolve(encrypted);
                }
            });
        });
    }

    async handleSignedAndEncryptedMessage( parsedMessage ) {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            if ( typeof parsedMessage.delivery_type !== 'undefined' &&
                parsedMessage.delivery_type == 'nacl_box') {
                const sourceJku = parsedMessage.source_jku;
                const targetJku = parsedMessage.target_jku;
                var hash = sourceJku;
                if (sourceJku.startsWith('xrp://')) {
                    hash = sourceJku.substring(6);
                }
                aqfr.getTx(hash).then(function (sourceKeySet) {
                    if (typeof sourceKeySet.result.Memos !== 'undefined') {
                        const memo = sourceKeySet.result.Memos[0];
                        const memoType = aqfr.fromHex(memo.Memo.MemoType);
                        const memoData = aqfr.fromHex(memo.Memo.MemoData);
                        const parsedSourceKeySet = JSON.parse(memoData);
                        if (memoType == 'publickeys') {
                            const open = nacl.box.open(decodeBase64(parsedMessage.payload),
                                decodeBase64(parsedMessage.nonce),
                                decodeBase64(parsedSourceKeySet.data_json.enc.key),
                                aqfr.keyStore[targetJku].enc.keyPair.secretKey);
                            resolve({ msg_raw : parsedMessage,
                                source_xrp_address : sourceKeySet.result.Account,
                                target_xrp_address : aqfr.xrpAddress,
                                msg_payload : JSON.parse(encodeUTF8(open)) });
                        }
                        else {
                            console.log('ignoring, non jwks memo found on xrp jwks pointer');
                            reject({errors: [{
                                    error: 'ignoring, non jwks memo found on xrp jwks pointer'
                                }]});
                        }
                    }
                });
            }
            else {
                console.log('non nacl_box delivery type');
                reject({errors: [{
                        error: 'non nacl_box  delivery type'
                    }]});
            }
        });

    }

    async sendSignedAndEncryptedMessage( data, destinationAddress, amount="20" ) {

        const theirJwkRecord = await this.getFirstRecordByType(destinationAddress, 'publickeys');
        if (typeof theirJwkRecord.hash === 'undefined') {
            console.log("could not find their jwks");
            return;
        }
        const currentKeySet = this.keyStore.current;

        const nonce = new Uint8Array(nacl.box.nonceLength);
        for (var i = 0; i < nonce.length; i++) nonce[i] = (32+i) & 0xff;
        const msg = decodeUTF8(JSON.stringify(data));
        const box =
            encodeBase64(
                nacl.box(msg, nonce, decodeBase64(theirJwkRecord.data.data_json.enc.key), currentKeySet.enc.keyPair.secretKey));

        const encrypted = {
            delivery_type : 'nacl_box',
            source_jku : currentKeySet.xrpHash,
            source_kid: currentKeySet.enc.kid,
            target_jku : theirJwkRecord.hash,
            target_kid: theirJwkRecord.data.data_json.enc.kid,
            payload: box,
            nonce : encodeBase64( nonce )
        };
        return await this.pay(destinationAddress, amount,
            'message',
            encrypted);
    }

    async signSaveAndNotify( key, data, notificationAddress ) {
        const currentKeySet = this.keyStore.current;
        const sig = nacl.sign.detached(decodeUTF8(JSON.stringify(data)), currentKeySet.sig.keyPair.secretKey);
        return this.saveAndNotify( key, { delivery_type : 'nacl_signed',
            jku : currentKeySet.xrpHash, kid: currentKeySet.sig.kid, payload: JSON.stringify(data), sig : encodeBase64( sig )
        }, notificationAddress);
    }

    async rotateKeys( notificationAddress ) {
        const signingKp = nacl.sign.keyPair();
        const base64EncodedSigningKey = encodeBase64(signingKp.publicKey);
        const signingKid = Math.random().toString(36).substring(2, 6);

        const encKp = nacl.box.keyPair();
        const base64EncodedEncKey = encodeBase64(encKp.publicKey);
        const encKid = Math.random().toString(36).substring(2, 6);


        const jwkXrpHash = await this.saveAndNotify('publickeys', {
                sig : {
                    alg: "ed25519",
                    kid: signingKid, use: 'sig',
                    key: base64EncodedSigningKey
                },
                enc : {
                    alg: "x25519-xsalsa20-poly1305",
                    kid: encKid, use: 'enc',
                    key: base64EncodedEncKey
                }
            },
            notificationAddress );
        await this.saveJwks( jwkXrpHash, {
            sig : {
                alg: "ed25519",
                kid: signingKid,
                use: 'sig',
                keyPair: signingKp
            },
            enc : {
                alg: "x25519-xsalsa20-poly1305",
                kid: encKid,
                use: 'enc',
                keyPair: encKp
            },
            xrpHash : jwkXrpHash
        } );

        return jwkXrpHash;
    }

    async saveJwks(jwkXrpHash, store) {
        this.keyStore.current = store;
        this.keyStore[jwkXrpHash] = store;
        this.keyStoreListener(jwkXrpHash, store);
    }

    handleMessage( fromAddress, memoData, callback ) {
        const aqfr = this;
        const parsedMessage = JSON.parse(memoData);
        if ( typeof parsedMessage.data_json.delivery_type !== 'undefined' &&
            parsedMessage.data_json.delivery_type == 'nacl_box') {
            const sourceJku = parsedMessage.data_json.source_jku;
            const targetJku = parsedMessage.data_json.target_jku;
            var hash = sourceJku;
            if (sourceJku.startsWith('xrp://')) {
                hash = sourceJku.substring(6);
            }
            aqfr.getTx(hash).then(function (sourceKeySet) {
                if (typeof sourceKeySet.result.Memos !== 'undefined') {
                    const memo = sourceKeySet.result.Memos[0];
                    const memoType = aqfr.fromHex(memo.Memo.MemoType);
                    const memoData = aqfr.fromHex(memo.Memo.MemoData);
                    const parsedSourceKeySet = JSON.parse(memoData);
                    if (memoType == 'publickeys') {
                        const open = nacl.box.open(decodeBase64(parsedMessage.data_json.payload),
                            decodeBase64(parsedMessage.data_json.nonce),
                            decodeBase64(parsedSourceKeySet.data_json.enc.key),
                            aqfr.keyStore[targetJku].enc.keyPair.secretKey);
                        aqfr.emit('received-message', { msg_raw : parsedMessage,
                            msg_payload : JSON.parse(encodeUTF8(open)) });
                        callback({ msg_raw : parsedMessage,
                            msg_payload : JSON.parse(encodeUTF8(open)) });
                        aqfr.promiseWsAccountInfo(aqfr.xrpAddress).then(function(accountInfo) {
                            // noop
                        });
                    }
                    else {
                        console.log('ignoring, non jwks memo found on xrp jwks pointer');
                    }
                }
            });
        }
    }



    handleNotification( memoData , callback) {
        const aqfr = this;
        const txnHash = JSON.parse(memoData).data_json.hash;
        var hash = txnHash;
        if (txnHash.startsWith('xrp://')) {
            hash = txnHash.substring(6);
        }
        this.getTx(hash).then(function (data) {
            if (typeof data.result.Memos !== 'undefined') {
                const memo = data.result.Memos[0];
                const memoType = aqfr.fromHex(memo.Memo.MemoType);
                const memoData = aqfr.fromHex(memo.Memo.MemoData);
                const parsedObj = JSON.parse(memoData);
                // this is a jws
                if (typeof parsedObj.data_json.jku !== 'undefined' &&
                    typeof parsedObj.data_json.kid !== 'undefined' &&
                    typeof parsedObj.data_json.payload !== 'undefined' &&
                    typeof parsedObj.data_json.sig !== 'undefined') {

                    const jku = parsedObj.data_json.jku;
                    const jkuHash = jku.substring(6);

                    aqfr.getTx(jkuHash).then(function (jwks) {
                        if (typeof jwks.result.Memos !== 'undefined') {
                            const jwksMemo = jwks.result.Memos[0];
                            const jwksMemoType = aqfr.fromHex(
                                jwksMemo.Memo.MemoType);
                            const jwksMemoData = aqfr.fromHex(
                                jwksMemo.Memo.MemoData);
                            if (jwksMemoType == 'publickeys') {
                                const parsedKeyRecord =JSON.parse(jwksMemoData);
                                if (nacl.sign.detached.verify(decodeUTF8(parsedObj.data_json.payload), decodeBase64( parsedObj.data_json.sig), decodeBase64(parsedKeyRecord.data_json.sig.key))) {
                                    aqfr.emit('received-verified-notification', { notification : parsedObj, msg_type: memoType, jws: true, verification: parsedKeyRecord.data_json.sig,
                                        msg_payload : JSON.parse( parsedObj.data_json.payload ) });

                                    callback({ notification : parsedObj, msg_type: memoType, jws: true, verification: parsedKeyRecord.data_json.sig,
                                        msg_payload : JSON.parse( parsedObj.data_json.payload ) });
                                }
                                else {
                                    console.log("not verified:" + parsedObj.data_json.payload);
                                }
                            }
                            else {
                                console.log('ignoring, non jwks memo found on xrp jwks pointer');
                            }
                        }
                    });
                }
                // this is a non jws
                else {
                    aqfr.emit('received-non-verified-notification', { notification : parsedObj, msg_type: memoType, jws: false, msg_payload : parsedObj.data_json });
                    callback({ notification : parsedObj, msg_type: memoType, jws: false, msg_payload : parsedObj.data_json });
                }
            }
        });
    }

    reSubscribe() {
        const aqfr = this;
        this.subscribeCallback = function (subscriptionResponse) {
            const parsedResponse = JSON.parse(subscriptionResponse);
            if (typeof parsedResponse.transaction !== 'undefined'
                && typeof parsedResponse.transaction.Memos !== 'undefined') {
                const memo = parsedResponse.transaction.Memos[0];
                const memoType = aqfr.fromHex(memo.Memo.MemoType);
                const memoData = aqfr.fromHex(memo.Memo.MemoData);
                if (memoType == 'notification') {
                    aqfr.handleNotification(memoData, aqfr.dataCallback);
                }
                else if (memoType == 'message') {
                    if (this.xrpAddress != null && parsedResponse.transaction.Destination == this.xrpAddress) {
                        aqfr.handleMessage(parsedResponse.transaction.Account, memoData, aqfr.dataCallback);
                    }
                }
                else if (memoType == 'publickeys') {
                    console.log('MemoData:' + (typeof memoData));
                    if (this.xrpAddress != null && typeof JSON.parse(memoData).address !== 'undefined' &&
                        JSON.parse(memoData).address == this.xrpAddress) {
                        console.log('our public keys received in subscription response');
                    }
                    else {
                        // this is a non-notification message.
                        console.log(
                            'Subscription Other Public Keys Response: ' + aqfr.xrpAddress
                            + ' -> ' + memoData);
                    }
                }
                else {
                    // this is a non-notification message.
                    console.log(
                        'Subscription Other Response: ' + aqfr.xrpAddress
                        + ' -> ' + (memoType) + ':' + memoData);
                }
            } else {
                // this is the subscription ack message.
                if (typeof JSON.parse(subscriptionResponse).id !== 'undefined'
                    && JSON.parse(subscriptionResponse).id
                    == 'Subscribe to Central') {
                    console.log(
                        "Subscription Inited: " + aqfr.xrpAddress);
                }
            }

        };
        const accounts = [];
        if (this.xrpAddress != null) {
            accounts.push(this.xrpAddress);
        }
        if (typeof this.network !== 'undefined') {
            accounts.push(this.network);
        }
        const request = {
            "id": "Subscribe to Central",
            "command": "subscribe",
            "accounts": accounts
        };
       // console.log('--> subscribe to central:' + JSON.stringify(request));
        this.ws.send(JSON.stringify(request));
    }

    subscribe(callback, subscribeAddress) {

        if (typeof subscribeAddress !== 'undefined') {
            this.network = subscribeAddress;
        }
        this.network = subscribeAddress;
        this.dataCallback = callback;

        this.reSubscribe();
    }

    async setDomain( domain ) {
        const aqfr = this;

        return new Promise(function (resolve, reject) {
            const txn = {
                "TransactionType": "AccountSet",
                "Account": aqfr.xrpAddress,
                "Sequence": aqfr.sequence+1,
                "Domain": aqfr.toHex(domain).toUpperCase(),
                "Fee": "20"
            };
            const signed = aqfr.api.sign(JSON.stringify(txn), aqfr.secret);
            const txnObj = {
                "id": aqfr.id++,
                "command": "submit",
                "tx_blob": signed.signedTransaction
            };
            aqfr.requestMap[txnObj.id.toString()] = function (data) {
                aqfr.setSequence(data.result.tx_json.Sequence, 'domain');
                resolve(data);
            };
            //console.log('--> account set');
            aqfr.ws.send(JSON.stringify(txnObj));
        });

    }

    async ping() {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            const request = {
                "id": aqfr.id++,
                "command": "ping"
            };
            aqfr.requestMap[request.id.toString()] = function (data) {
                resolve(data);
            };
            //console.log('--> ping');
            aqfr.ws.send(JSON.stringify(request));
        });

    }

    async promiseWsAccountInfo(xrpAddress) {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            const request = {
                "id": aqfr.id++,
                "command": "account_info",
                "account": xrpAddress
            };
            aqfr.requestMap[request.id.toString()] = function (data) {
                if (xrpAddress == aqfr.xrpAddress) {
                    if (typeof data.error !== 'undefined') {
                        console.log('error received on account balance:' + data.error);
                    }
                    else if (aqfr.balance.balance != data.result.account_data.Balance) {
                        aqfr.balance.balance = data.result.account_data.Balance;
                        aqfr.emit('account-balance', data.result.account_data.Balance);
                    }

                }
                resolve(data);
            };
            //console.log('--> account info');
            aqfr.ws.send(JSON.stringify(request));
        });

    }

    async getFirstRecordByType(xrpAddress, recordType) {
        const aqfr = this;
        const data = await this.promiseWsAccountInfo(xrpAddress);
        var prevHash = 'NONE';
        if (typeof data.result !== 'undefined' && typeof data.result.account_data.Domain !== 'undefined') {
            const domain = data.result.account_data.Domain;
            const decodedDomain = aqfr.fromHex(domain);
            if (decodedDomain.startsWith('xrp://')) {
                prevHash = decodedDomain.substring(6);
            }
        }

        return new Promise(function (resolve, reject) {
            if (prevHash == 'NONE') {
                console.log('no records found');
                resolve( {} );
            } else {
                resolve( aqfr.nagivateRecordsByType(prevHash, recordType));
            }
        });

    }

    nagivateRecordsByType(prevHash, recordType ) {
        const aqfr = this;
        const thisHash = prevHash;
        return new Promise(function(resolve, reject) {
            aqfr.getTx(prevHash).then(function (data) {

                if (typeof data.result !== 'undefined' && typeof data.result.Memos
                    !== 'undefined') {
                    const memo = data.result.Memos[0];
                    const memoType = aqfr.fromHex(memo.Memo.MemoType);
                    const memoData = aqfr.fromHex(memo.Memo.MemoData);
                    const parsedMemoData = JSON.parse(memoData);
                    if (memoType == recordType) {
                        resolve( { hash: 'xrp://' + thisHash, data: parsedMemoData});
                    }
                    if (parsedMemoData.prev_hash != 'xrp://NONE') {
                        var prevHash = parsedMemoData.prev_hash;
                        if (parsedMemoData.prev_hash.startsWith('xrp://')) {
                            prevHash = parsedMemoData.prev_hash.substring(6);
                        }
                        resolve(aqfr.nagivateRecordsByType(prevHash, recordType));
                    } else {
                        resolve({});
                    }
                } else {
                    resolve({});
                }
            });

        });

    }


    async getTx(hash) {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            const request = {
                "id": aqfr.id++,
                "command": "tx",
                "transaction": hash,
                "binary": false
            };
            aqfr.requestMap[request.id.toString()] = function (data) {
                resolve(data);
            };
            //console.log('--> get txn');
            aqfr.ws.send(JSON.stringify(request));
        });

    }

    async pay(destinationAddress, amount, memoKey, memoData ) {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            const memoRecord = {
                "timestamp": new Date().toISOString(),
                "data_json": memoData,
                "address": aqfr.xrpAddress
            };

            const memoKeyHex = aqfr.toHex(memoKey).toUpperCase();
            const memoDataHex = aqfr.toHex(JSON.stringify(
                memoRecord)).toUpperCase();

            const txn = {
                "TransactionType": "Payment",
                "Account": aqfr.xrpAddress,
                "Destination": destinationAddress,
                "Amount": amount,
                "Fee": "20",
                "Memos": [
                    {
                        "Memo": {
                            "MemoType": memoKeyHex,
                            "MemoData": memoDataHex
                        }
                    }
                ],
                "Sequence": (aqfr.sequence+1)
            };
            const signed = aqfr.api.sign(JSON.stringify(txn), aqfr.secret);
            const txnObj = {
                "id": aqfr.id++,
                "command": "submit",
                "tx_blob": signed.signedTransaction
            };

            aqfr.requestMap[txnObj.id.toString()] = function (data) {
                aqfr.setSequence(data.result.tx_json.Sequence, 'pay');
                resolve(data.result);
            };
            //console.log('--> pay');
            aqfr.ws.send(JSON.stringify(txnObj));
        })


    }

    async setMemo(memoKey, memoData ) {
        const aqfr = this;
        const data = await this.promiseWsAccountInfo(this.xrpAddress);

        return new Promise(function (resolve, reject) {


            var prevHash = 'NONE';
            if (typeof data.result.account_data.Domain !== 'undefined') {

                const domain = data.result.account_data.Domain;
                const decodedDomain = aqfr.fromHex(domain);

                if (decodedDomain.startsWith('xrp://')) {
                    prevHash = decodedDomain.substring(6);
                }
            }

            const memoRecord = {
                "prev_hash": 'xrp://' + prevHash,
                "timestamp": new Date().toISOString(),
                "data_json": memoData,
                "address": aqfr.xrpAddress
            };

            const memoKeyHex = aqfr.toHex(memoKey).toUpperCase();
            const memoDataHex = aqfr.toHex(JSON.stringify(
                memoRecord)).toUpperCase();

            const txn = {
                "TransactionType": "AccountSet",
                "Account": aqfr.xrpAddress,
                "Sequence": aqfr.sequence+1,
                "Memos": [
                    {
                        "Memo": {
                            "MemoType": memoKeyHex,
                            "MemoData": memoDataHex
                        }
                    }
                ],
                "Fee": "20"
            };
            const signed = aqfr.api.sign(JSON.stringify(txn), aqfr.secret);
            const txnObj = {
                "id": aqfr.id++,
                "command": "submit",
                "tx_blob": signed.signedTransaction
            };

            aqfr.requestMap[txnObj.id.toString()] = function (data) {
                aqfr.setSequence(data.result.tx_json.Sequence, 'memos');
                resolve(data.result);
            };
            //console.log('--> set memo:' + aqfr.xrpAddress + ' ' + memoKey);
            aqfr.ws.send(JSON.stringify(txnObj));
        })


    }

    async connectWs(options) {
        this.wsOptions = options;
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            if (aqfr.ws == null || aqfr.connectedApi == false) {
                aqfr.ws = new WebSocket(typeof options.server === 'undefined'
                    ? 'wss://s.altnet.rippletest.net:51233'
                    : 'wss://s1.ripple.com/');
                aqfr.api = new RippleAPI();
                aqfr.ws.onopen = function open() {
                    console.log('connected');
                    aqfr.connectedApi = true;
                    aqfr.heartbeat();
                    if (aqfr.dataCallback != null) {
                        aqfr.reSubscribe();
                    }
                    resolve('connected');


                };

                aqfr.ws.onerror = function(error) {
                    console.log('ws error:' + JSON.stringify(error));
                };

                aqfr.ws.onclose = function close() {
                    console.log('disconnected');
                    aqfr.ws = null;
                    aqfr.connectedApi = false;
                    if (aqfr.pingTimeout != null) {
                        clearTimeout(aqfr.pingTimeout);
                    }
                };

                aqfr.ws.onmessage = function incoming(data) {
                    const response = JSON.parse(data.data);
                    if (typeof response.id !== 'undefined' && response.id
                        != 'Subscribe to Central') {
                        if (typeof aqfr.requestMap[JSON.parse(
                            data.data).id.toString()]
                            !== 'undefined') {
                            const callback = aqfr.requestMap[JSON.parse(
                                data.data).id.toString()];
                            delete aqfr.requestMap[JSON.parse(
                                data.data).id.toString()];
                            callback(JSON.parse(data.data));
                        }
                    } else {
                        aqfr.subscribeCallback(data.data);
                    }
                };
            } else {
                resolve(aqfr.connectedApi ? 'connected' : 'disconnected');
            }
        });

    }

    getAccountTxns(xrpAddress, callback) {
        const request = {
            "id": this.id++,
            "command": "account_tx",
            "account": this.xrpAddress,
            "ledger_index_min": -1,
            "ledger_index_max": -1,
            "binary": false,
            "limit": 2,
            "forward": false
        };
        this.requestMap[request.id.toString()] = callback;
        //console.log('--> get account txns');
        this.ws.send(JSON.stringify(request));
    }

    toHex(s) {
        // utf8 to latin1
        var s = unescape(encodeURIComponent(s));
        var h = '';
        for (var i = 0; i < s.length; i++) {
            h += s.charCodeAt(i).toString(16);
        }
        return h
    }

    fromHex(h) {
        var s = '';
        for (var i = 0; i < h.length; i += 2) {
            s += String.fromCharCode(parseInt(h.substr(i, 2), 16));
        }
        return decodeURIComponent(escape(s))
    }

    getMode() {
        return this.mode;
    }

    async getFee() {
        const aqfr = this;
        return new Promise(function (resolve, reject) {
            const request = {
                "id": aqfr.id++,
                "command": "fee"
            };
            aqfr.requestMap[request.id.toString()] = function (data) {
                resolve(data);
            };
            //console.log('--> get fee');
            aqfr.ws.send(JSON.stringify(request));
        });
    }

    setSequence(sequence, why) {
        this.sequence = sequence;
    }

    async initAccount(options) {
        if (this.xrpAddress == null) {
            if (typeof options.xrpAddress === 'undefined') {
                let data = await this.initTestAccount();
                this.xrpAddress = data.data.account.address;
                this.secret = data.data.account.secret;
                this.setSequence(0, 'init account');

            } else {
                this.xrpAddress = options.xrpAddress;
                this.secret = options.secret;
                const accountInfo = await this.promiseWsAccountInfo(this.xrpAddress);

                this.setSequence(accountInfo.result.account_data.Sequence-1, 'init account');
            }
            if (typeof options.keyStore !== 'undefined' && options.keyStore !== null) {
                this.keyStore = options.keyStore;
            }
            if (typeof options.keyStoreListener !== 'undefined' && options.keyStoreListener !== null) {
                this.keyStoreListener = options.keyStoreListener;
            }

        }
        return (this.xrpAddress);


    }

    async initTestAccount() {

        let result = axios.post(
            'https://faucet.altnet.rippletest.net/accounts');
        return Promise.resolve(result);
    }

    getAddress() {
        return this.xrpAddress;
    }
}

exports.Aqfr = Aqfr;
