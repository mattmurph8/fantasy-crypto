const nacl = require('tweetnacl');
const decodeUTF8 = require('tweetnacl-util').decodeUTF8;
const encodeUTF8 = require('tweetnacl-util').encodeUTF8;
const encodeBase64 = require('tweetnacl-util').encodeBase64;
const decodeBase64 = require('tweetnacl-util').decodeBase64;
const events = require('events');


class AqfrChannel extends events.EventEmitter {
    constructor(aqfr, channels = {}, keyListener = function(channelKeys) {
        console.log('channel keys update: channelId:' + channelKeys.channel_id + ', channelKid:' + channelKeys.channel_kid);
    }) {
        super();
        this.aqfr = aqfr;
        this.channels = channels;
        this.keyListener = keyListener;
    }

    randomKey() {
        return encodeBase64(
            nacl.randomBytes(nacl.secretbox.keyLength));
    }

    randomNonce() {
        return encodeBase64(
            nacl.randomBytes(nacl.secretbox.nonceLength));
    }

    removeMember(channelId, memberAddress) {
        const ref = this;
        return new Promise(function (resolve, reject) {
                if (typeof ref.channels[channelId] === "undefined") {
                    reject('no channel found');
                }
                else {
                    ref.channels[channelId].members =
                        ref.channels[channelId].members.filter(function(value, index, arr){
                        return value != memberAddress;
                    });
                    ref.emit('channel', ref.channels[channelId]);
                    resolve( ref.channels[channelId] );
                }
            }
        );
    }

    addMember(channelId, memberAddress) {
        const ref = this;
        return new Promise(function (resolve, reject) {
                if (typeof ref.channels[channelId] === "undefined") {
                    reject('no channel found');
                }
                else {
                    const foundLength = ref.channels[channelId].members.filter(value => value == memberAddress).length;
                    console.log('found length:' + foundLength);
                    if (foundLength == 0) {
                       ref.channels[channelId].members.push(memberAddress);
                       console.log('sending keys to new member');

                       const keysMsg = {
                           message_type: 'channel_keys',
                           channel_id : channelId,
                           channel_kid : ref.channels[channelId].kid,
                           nonce : ref.channels[channelId].nonce,
                           key: ref.channels[channelId].key,
                           members: ref.channels[channelId].members
                       };
                       ref.keyListener(keysMsg);
                         ref.aqfr.sendSignedAndEncryptedMessage(keysMsg, memberAddress).then(function(result){
                            console.log('keys sent to new member:' + memberAddress);
                            resolve(result);
                         });
                    }
                    else {
                        resolve('done');
                    }
                }
            }
        );
    }

    rotateKey(channelId) {
        const ref = this;
        return new Promise(function (resolve, reject) {
                if (typeof ref.channels[channelId] === "undefined") {
                    reject('no channel found');
                }
                else {
                    const key = ref.randomKey();
                    const nonce = ref.randomNonce();
                    ref.channels[channelId].kid = Math.random().toString(36).substring(2, 6);
                    ref.channels[channelId].key = key;
                    ref.channels[channelId].nonce = nonce;
                    ref.emit('channel', ref.channels[channelId]);
                    const membersToNotify =
                        ref.channels[channelId].members.filter(function(value, index, arr){
                        return value != ref.aqfr.xrpAddress;
                    });
                    const keyMsg = {
                        message_type: 'channel_keys',
                        channel_id : channelId,
                        channel_kid : ref.channels[channelId].kid,
                        nonce : ref.channels[channelId].nonce,
                        key: ref.channels[channelId].key,
                        members: ref.channels[channelId].members
                    };
                    ref.keyListener(keyMsg);
                    console.log('members to notify:' + JSON.stringify(membersToNotify));
                    const requests = membersToNotify.map((item) => {
                        return ref.aqfr.sendSignedAndEncryptedMessage(keyMsg);
                    });
                    Promise.all(requests).then(() => {
                        console.log('all updates sent');
                        resolve( ref.channels[channelId] );
                    });
                }
            }
        );
    }


    updateChannel(channelId, kid, key, nonce, members) {
        const comp = this;
        if (typeof this.channels[channelId] === "undefined") {
            if (typeof members !== 'undefined') {
                const membersNotMe =
                    members.filter(function(value, index, arr){
                        return value != comp.aqfr.xrpAddress;
                    });
                membersNotMe.push(this.aqfr.xrpAddress);
                this.channels[channelId] = {
                    kid: kid,
                    key: key,
                    nonce: nonce,
                    channelId: channelId,
                    members: membersNotMe
                };
            }
            else {
                this.channels[channelId] = {
                    kid: kid,
                    key: key,
                    nonce: nonce,
                    channelId: channelId,
                    members: [this.aqfr.xrpAddress]
                };
            }
        } else {
            this.channels[channelId].kid = kid;
            this.channels[channelId].key = key;
            this.channels[channelId].nonce = nonce;
            if (typeof members !== 'undefined') {
                const membersNotMe =
                    members.filter(function(value, index, arr){
                        return value != comp.aqfr.xrpAddress;
                    });
                membersNotMe.push(this.aqfr.xrpAddress);
                this.channels[channelId].members = membersNotMe;
            }

        }
        this.emit('channel', this.channels[channelId]);
        return this.channels[channelId];
    }

    newChannel(channelId) {
        const key = this.randomKey();
        const nonce = this.randomNonce();
        this.channels[channelId] = {
            kid: Math.random().toString(36).substring(2, 6),
            key: key,
            nonce: nonce,
            channelId: channelId,
            members: [this.aqfr.xrpAddress]
        };
        this.emit('channel', this.channels[channelId]);
        return this.channels[channelId];
    }

    decryptForChannel(data) {
        const ref = this;
        return new Promise(function (resolve, reject) {
                if (typeof data.channel_id == 'undefined') {
                    reject('no channel_id found in the message');
                }
                else if (typeof ref.channels[data.channel_id] === "undefined") {
                    reject('no channel found');
                }
                else if (typeof data.channel_kid == 'undefined') {
                    reject('no kid found in the message');
                }
                else if ( ref.channels[data.channel_id].kid != data.channel_kid) {
                    reject('kid mismatch');
                }
                else {
                    const decoded =
                        ref.decrypt( ref.decodeKey(ref.channels[data.channel_id].key),
                            ref.decodeNonce(ref.channels[data.channel_id].nonce), data.payload );
                    resolve(
                        {
                            raw: data,
                            payload:  JSON.parse(decoded)
                        }
                    );
                }
            }
        );
    }

    encryptForChannel(channelId, data) {
        const ref = this;
        return new Promise(function (resolve, reject) {
                if (typeof ref.channels[channelId] === "undefined") {
                    reject('no channel found');
                }
                else {
                    const encoded =
                        ref.encrypt(JSON.stringify(data), ref.channels[channelId].key, ref.channels[channelId].nonce );
                    resolve( {
                        delivery_type : 'nacl_secret_box',
                        channel_id : channelId,
                        channel_kid : ref.channels[channelId].kid,
                        nonce : ref.channels[channelId].nonce,
                        payload: encoded
                    });
                }
            }
        );
    }


    decodeKey(key) {
        try {
            const k = decodeBase64(key);
            if (k.length != nacl.secretbox.keyLength) {
                console.log(
                    'Bad key length: must be ' + nacl.secretbox.keyLength
                    + ' bytes');
                return null;
            }
            return k;
        } catch (e) {
            console.log('Failed to decode key from Base64');
            return null;
        }
    }

    decodeNonce(nonce) {
        try {
            const n = decodeBase64(nonce);
            if (n.length != nacl.secretbox.nonceLength) {
                console.log(
                    'Bad nonce length: must be ' + nacl.secretbox.nonceLength
                    + ' bytes');
                return null;
            }
            return n;
        } catch (e) {
            this.error('Failed to decode nonce from Base64');
            return null;
        }
    };

    encrypt(message, key, nonce) {
        console.log('msg type:' + (typeof message));
        console.log('key type:' + (typeof key));
        console.log('nonce type:' + (typeof nonce));
        const m = decodeUTF8(message);
        const box = nacl.secretbox(m, this.decodeNonce(nonce), this.decodeKey(key));
        console.log('box type:' + (typeof box));
        return encodeBase64(box);
    }

    decrypt(k, n, box) {
        var b;
        var m;
        try {
            b = decodeBase64(box);
        } catch (ex) {
            console.log('Cannot decode box');
            return null;
        }
        m = nacl.secretbox.open(b, n, k);
        if (m === false) {
            console.log('Failed to decrypt');
            return null;
        }
        try {
            return encodeUTF8(m);
        } catch (ex) {
            console.log('Cannot decode decrypted message to string');
            return;
        }
    }

    getAqfr() {
        return this.aqfr;
    }
}

export { AqfrChannel };
